# open-source-chip-design-ws2526

## Toolchain Installation Guide

In this course we will use open-source tools to develop our integrated circuit. Our primary language will be plain Verilog. You may also use some SystemVerilog features, but we will focus on plain Verilog. Furthermore, please note that even though SystemVerilog is an established language, the synthesis tools may not always support SystemVerilog.

In order to simulate our designs we will require 3 tools:

1) [Verilator](https://www.veripool.org/verilator/): This tool allows you to "compile" Verilog into C++. This has several advantages over traditional simulation as you do not need a separate simulator and can utilise the raw power of your processor instead of "interpreting" a design through a middleware. A downside of Verilator is the fact that only discrete circuits can be emulated. So combinatorial loops (e.g., ring oscillators etc.) do not work.
We advice to perform the Git Quick Install shown [here](https://veripool.org/guide/latest/install.html), but without the final "sudo make install" step. This allows you to quickly swap Verilator installs if necessary. Afterwards you should extend your CLI environment with a VERILATOR_ROOT which points to the directory of Verilator. For example: /home/user/verilator . You can do this by extending your .bashrc (if you are using bash). You may also extend your PATH with VERILATOR_ROOT.

2) [Cocotb](https://www.cocotb.org/): We will use cocotb, a python framework, to write test benches and "run" your verilated design. The main advantage over traditional Verilator or even plain Verilog test benches is the ease of use. You can simply set inputs and outputs using Python. You can use all Python features, as it is a normal Python program. Several additional packages exist, which make cocotb even more useful. The UART extension simulates a whole UART transmission for you, so once we include a UART module into our design, we do not have to figure out when to set the TX line high or low. This is done by the UART extension. Similarly, normal python packages can be used to do computations. The Python cryptodome library can calculate AES encryptions for us, which we can use to check the output. To install cocotb, simply set up a new python virtual environment (recommended to not poison your global python environment with packages). Activate the python virtual environment and run  " pip install "cocotb~=2.0" ". 

3) [Surfer](https://marketplace.visualstudio.com/items?itemName=surfer-project.surfer) or [GTKWave](https://gtkwave.sourceforge.net/): Sometimes we are not only interested in the final output but in the intermediate steps. Of course you could print this using python but this would get way to verbose. Instead we will generate waveform files. Imagine them like a very detailed oscilloscope which can observe every signal in your design. The Surfer Extension for VSCode is highly recommended, it is snappy and integrated right into your Code Editor. Alternatively, you can install GTKWave. The only advantage that I can see is that GTKWave allows you to reload the waveform, after you fixed something and reran the simulation. With Surfer you have to close and open the waveform again, as far as I can see. Personally, I switched completely to Surfer. Surfer also exists as a standalone application.

We advice the usage of VSCode.